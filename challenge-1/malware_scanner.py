#!/usr/bin/env python3
"""
Script de dÃ©tection de malware sur un site web
Analyse une URL donnÃ©e et gÃ©nÃ¨re un rapport dÃ©taillÃ©
"""

import argparse
import requests
import re
import json
from urllib.parse import urlparse, urljoin
from datetime import datetime
from bs4 import BeautifulSoup
import hashlib
from typing import Dict, List, Set


class MalwareScanner:
    """Scanner de malware pour sites web"""
    
    def __init__(self, url: str):
        self.url = url
        self.parsed_url = urlparse(url)
        self.results = {
            "url": url,
            "timestamp": datetime.now().isoformat(),
            "threats_found": [],
            "suspicious_patterns": [],
            "external_links": [],
            "scripts": [],
            "iframes": [],
            "obfuscated_code": [],
            "security_headers": {},
            "risk_level": "LOW"
        }
        
        # Patterns suspects courants
        self.malicious_patterns = [
            r'eval\s*\(',  # ExÃ©cution de code dynamique
            r'document\.write',  # Injection de contenu
            r'fromCharCode',  # Obfuscation de caractÃ¨res
            r'unescape\s*\(',  # DÃ©codage suspect
            r'atob\s*\(',  # DÃ©codage base64
            r'<iframe[^>]*src=["\']https?://(?!{})'.format(re.escape(self.parsed_url.netloc)),  # iframes externes
            r'window\.location\s*=',  # Redirections
            r'\.innerHTML\s*=',  # Injection HTML
            r'base64_decode',  # DÃ©codage base64 (PHP)
            r'exec\s*\(',  # ExÃ©cution de commandes
            r'shell_exec',  # ExÃ©cution shell
            r'system\s*\(',  # Appels systÃ¨me
            r'passthru',  # ExÃ©cution de commandes
            r'cryptocurrency|bitcoin|ethereum|mining|cryptojacking',  # Cryptomining
        ]
        
        # Domaines suspects connus
        self.suspicious_domains = [
            'bit.ly', 'tinyurl.com', 'goo.gl',  # Raccourcisseurs d'URL
            '.tk', '.ml', '.ga', '.cf', '.gq',  # TLDs gratuits souvent malveillants
        ]
    
    def fetch_content(self) -> tuple:
        """RÃ©cupÃ¨re le contenu de la page"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Malware Scanner Bot)'
            }
            response = requests.get(self.url, headers=headers, timeout=10, verify=True)
            response.raise_for_status()
            return response.text, response.headers, response.status_code
        except requests.exceptions.RequestException as e:
            print(f"âŒ Erreur lors de la rÃ©cupÃ©ration de l'URL: {e}")
            return None, None, None
    
    def check_security_headers(self, headers: dict):
        """VÃ©rifie la prÃ©sence d'en-tÃªtes de sÃ©curitÃ©"""
        security_headers = [
            'Content-Security-Policy',
            'X-Frame-Options',
            'X-Content-Type-Options',
            'Strict-Transport-Security',
            'X-XSS-Protection'
        ]
        
        for header in security_headers:
            if header in headers:
                self.results["security_headers"][header] = headers[header]
            else:
                self.results["security_headers"][header] = "ABSENT"
                self.results["threats_found"].append({
                    "type": "missing_security_header",
                    "severity": "MEDIUM",
                    "description": f"En-tÃªte de sÃ©curitÃ© manquant: {header}"
                })
    
    def analyze_scripts(self, soup: BeautifulSoup):
        """Analyse les scripts JavaScript"""
        scripts = soup.find_all('script')
        
        for script in scripts:
            script_info = {
                "src": script.get('src', 'inline'),
                "inline": script.string is not None,
                "content_hash": None,
                "suspicious": False
            }
            
            # Analyse du contenu inline
            if script.string:
                content = script.string
                script_info["content_hash"] = hashlib.md5(content.encode()).hexdigest()
                
                # Recherche de patterns suspects
                for pattern in self.malicious_patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    if matches:
                        script_info["suspicious"] = True
                        self.results["suspicious_patterns"].append({
                            "type": "suspicious_script_pattern",
                            "pattern": pattern,
                            "matches": len(matches),
                            "context": content[:200]
                        })
                
                # DÃ©tection d'obfuscation
                if self.is_obfuscated(content):
                    script_info["obfuscated"] = True
                    self.results["obfuscated_code"].append({
                        "type": "obfuscated_script",
                        "hash": script_info["content_hash"],
                        "sample": content[:100]
                    })
                    self.results["threats_found"].append({
                        "type": "obfuscated_code",
                        "severity": "HIGH",
                        "description": "Code JavaScript fortement obfusquÃ© dÃ©tectÃ©"
                    })
            
            # VÃ©rification des scripts externes
            elif script.get('src'):
                src = script.get('src')
                if not src.startswith(('http://', 'https://', '//')):
                    src = urljoin(self.url, src)
                
                script_info["external_domain"] = urlparse(src).netloc
                
                # VÃ©rification de domaines suspects
                if any(domain in src for domain in self.suspicious_domains):
                    script_info["suspicious"] = True
                    self.results["threats_found"].append({
                        "type": "suspicious_external_script",
                        "severity": "HIGH",
                        "description": f"Script provenant d'un domaine suspect: {src}"
                    })
            
            self.results["scripts"].append(script_info)
    
    def analyze_iframes(self, soup: BeautifulSoup):
        """Analyse les iframes"""
        iframes = soup.find_all('iframe')
        
        for iframe in iframes:
            src = iframe.get('src', '')
            iframe_info = {
                "src": src,
                "suspicious": False
            }
            
            # VÃ©rification de domaine externe
            if src and not src.startswith(self.parsed_url.netloc):
                iframe_info["external"] = True
                iframe_domain = urlparse(src).netloc if src.startswith('http') else 'unknown'
                
                if any(domain in src for domain in self.suspicious_domains):
                    iframe_info["suspicious"] = True
                    self.results["threats_found"].append({
                        "type": "suspicious_iframe",
                        "severity": "MEDIUM",
                        "description": f"Iframe pointant vers un domaine suspect: {iframe_domain}"
                    })
            
            # Iframe invisible (technique de phishing)
            style = iframe.get('style', '')
            if 'display:none' in style.replace(' ', '') or 'width:0' in style.replace(' ', ''):
                iframe_info["hidden"] = True
                self.results["threats_found"].append({
                    "type": "hidden_iframe",
                    "severity": "HIGH",
                    "description": "Iframe invisible dÃ©tectÃ© (possible malware ou tracking)"
                })
            
            self.results["iframes"].append(iframe_info)
    
    def analyze_links(self, soup: BeautifulSoup):
        """Analyse les liens externes"""
        links = soup.find_all('a', href=True)
        external_links = []
        
        for link in links:
            href = link.get('href')
            if href.startswith(('http://', 'https://')):
                link_domain = urlparse(href).netloc
                if link_domain != self.parsed_url.netloc:
                    external_links.append({
                        "url": href,
                        "domain": link_domain,
                        "text": link.get_text(strip=True)[:50]
                    })
                    
                    # VÃ©rification de domaines suspects
                    if any(domain in href for domain in self.suspicious_domains):
                        self.results["threats_found"].append({
                            "type": "suspicious_link",
                            "severity": "MEDIUM",
                            "description": f"Lien vers un domaine suspect: {href}"
                        })
        
        self.results["external_links"] = external_links[:20]  # Limite Ã  20 liens
    
    def is_obfuscated(self, code: str) -> bool:
        """DÃ©tecte si le code est obfusquÃ©"""
        # CritÃ¨res d'obfuscation
        if len(code) < 100:
            return False
        
        # Ratio de caractÃ¨res non-alphanumÃ©riques Ã©levÃ©
        non_alnum = sum(1 for c in code if not c.isalnum() and c not in ' \n\t')
        ratio = non_alnum / len(code)
        
        # PrÃ©sence de chaÃ®nes hexadÃ©cimales longues
        hex_strings = re.findall(r'\\x[0-9a-fA-F]{2}', code)
        
        # Noms de variables suspects (trÃ¨s courts ou alÃ©atoires)
        short_vars = re.findall(r'\b[a-zA-Z_][a-zA-Z0-9_]{0,2}\b', code)
        
        return ratio > 0.4 or len(hex_strings) > 10 or len(short_vars) > 50
    
    def calculate_risk_level(self):
        """Calcule le niveau de risque global"""
        high_threats = sum(1 for t in self.results["threats_found"] if t["severity"] == "HIGH")
        medium_threats = sum(1 for t in self.results["threats_found"] if t["severity"] == "MEDIUM")
        
        if high_threats >= 3 or (high_threats >= 1 and medium_threats >= 3):
            self.results["risk_level"] = "CRITICAL"
        elif high_threats >= 1 or medium_threats >= 3:
            self.results["risk_level"] = "HIGH"
        elif medium_threats >= 1:
            self.results["risk_level"] = "MEDIUM"
        else:
            self.results["risk_level"] = "LOW"
    
    def scan(self) -> Dict:
        """Effectue le scan complet"""
        print(f"ğŸ” DÃ©but du scan de: {self.url}")
        
        # RÃ©cupÃ©ration du contenu
        content, headers, status_code = self.fetch_content()
        if not content:
            self.results["error"] = "Impossible de rÃ©cupÃ©rer le contenu"
            return self.results
        
        print(f"âœ“ Contenu rÃ©cupÃ©rÃ© (Code: {status_code})")
        
        # Analyse des en-tÃªtes de sÃ©curitÃ©
        print("ğŸ”’ VÃ©rification des en-tÃªtes de sÃ©curitÃ©...")
        self.check_security_headers(headers)
        
        # Parsing HTML
        soup = BeautifulSoup(content, 'html.parser')
        
        # Analyse des scripts
        print("ğŸ“œ Analyse des scripts JavaScript...")
        self.analyze_scripts(soup)
        
        # Analyse des iframes
        print("ğŸ–¼ï¸  Analyse des iframes...")
        self.analyze_iframes(soup)
        
        # Analyse des liens
        print("ğŸ”— Analyse des liens externes...")
        self.analyze_links(soup)
        
        # Calcul du niveau de risque
        self.calculate_risk_level()
        
        print(f"âœ… Scan terminÃ© - Niveau de risque: {self.results['risk_level']}")
        
        return self.results
    
    def generate_report(self, output_file: str = None):
        """GÃ©nÃ¨re un rapport dÃ©taillÃ©"""
        risk_colors = {
            "LOW": "ğŸŸ¢",
            "MEDIUM": "ğŸŸ¡",
            "HIGH": "ğŸŸ ",
            "CRITICAL": "ğŸ”´"
        }
        
        report = []
        report.append("=" * 80)
        report.append("RAPPORT D'ANALYSE DE MALWARE")
        report.append("=" * 80)
        report.append(f"\nğŸ“… Date: {self.results['timestamp']}")
        report.append(f"ğŸŒ URL analysÃ©e: {self.results['url']}")
        report.append(f"\n{risk_colors[self.results['risk_level']]} NIVEAU DE RISQUE: {self.results['risk_level']}")
        report.append("\n" + "=" * 80)
        
        # Menaces dÃ©tectÃ©es
        report.append(f"\nğŸš¨ MENACES DÃ‰TECTÃ‰ES: {len(self.results['threats_found'])}")
        report.append("-" * 80)
        if self.results['threats_found']:
            for i, threat in enumerate(self.results['threats_found'], 1):
                severity_icon = "ğŸ”´" if threat['severity'] == "HIGH" else "ğŸŸ¡"
                report.append(f"\n{i}. {severity_icon} [{threat['severity']}] {threat['type']}")
                report.append(f"   Description: {threat['description']}")
        else:
            report.append("âœ“ Aucune menace majeure dÃ©tectÃ©e")
        
        # En-tÃªtes de sÃ©curitÃ©
        report.append(f"\n\nğŸ”’ EN-TÃŠTES DE SÃ‰CURITÃ‰")
        report.append("-" * 80)
        for header, value in self.results['security_headers'].items():
            status = "âœ“" if value != "ABSENT" else "âœ—"
            report.append(f"{status} {header}: {value}")
        
        # Scripts analysÃ©s
        report.append(f"\n\nğŸ“œ SCRIPTS ANALYSÃ‰S: {len(self.results['scripts'])}")
        report.append("-" * 80)
        suspicious_scripts = [s for s in self.results['scripts'] if s.get('suspicious', False)]
        if suspicious_scripts:
            report.append(f"âš ï¸  Scripts suspects: {len(suspicious_scripts)}")
            for script in suspicious_scripts[:5]:
                report.append(f"   - {script.get('src', 'inline script')}")
        else:
            report.append("âœ“ Aucun script suspect dÃ©tectÃ©")
        
        # Code obfusquÃ©
        if self.results['obfuscated_code']:
            report.append(f"\n\nâš ï¸  CODE OBFUSQUÃ‰ DÃ‰TECTÃ‰: {len(self.results['obfuscated_code'])}")
            report.append("-" * 80)
            for code in self.results['obfuscated_code'][:3]:
                report.append(f"   Hash: {code['hash']}")
                report.append(f"   Extrait: {code['sample']}...")
        
        # Iframes
        if self.results['iframes']:
            report.append(f"\n\nğŸ–¼ï¸  IFRAMES: {len(self.results['iframes'])}")
            report.append("-" * 80)
            suspicious_iframes = [i for i in self.results['iframes'] if i.get('suspicious', False)]
            if suspicious_iframes:
                report.append(f"âš ï¸  Iframes suspects: {len(suspicious_iframes)}")
        
        # Liens externes
        report.append(f"\n\nğŸ”— LIENS EXTERNES: {len(self.results['external_links'])}")
        report.append("-" * 80)
        if self.results['external_links']:
            domains = set(link['domain'] for link in self.results['external_links'])
            report.append(f"Domaines uniques: {len(domains)}")
            for domain in list(domains)[:10]:
                report.append(f"   - {domain}")
        
        # Patterns suspects
        if self.results['suspicious_patterns']:
            report.append(f"\n\nğŸ” PATTERNS SUSPECTS DÃ‰TECTÃ‰S: {len(self.results['suspicious_patterns'])}")
            report.append("-" * 80)
            for pattern in self.results['suspicious_patterns'][:10]:
                report.append(f"   - Pattern: {pattern['pattern']} ({pattern['matches']} occurrences)")
        
        # Recommandations
        report.append("\n\nğŸ’¡ RECOMMANDATIONS")
        report.append("-" * 80)
        if self.results['risk_level'] in ['HIGH', 'CRITICAL']:
            report.append("âš ï¸  ATTENTION: Ce site prÃ©sente des risques Ã©levÃ©s!")
            report.append("   - Ne pas saisir d'informations personnelles")
            report.append("   - Ã‰viter de tÃ©lÃ©charger des fichiers")
            report.append("   - VÃ©rifier l'authenticitÃ© du site")
        elif self.results['risk_level'] == 'MEDIUM':
            report.append("âš ï¸  Prudence recommandÃ©e")
            report.append("   - VÃ©rifier les certificats SSL")
            report.append("   - ÃŠtre vigilant avec les liens externes")
        else:
            report.append("âœ“ Le site semble relativement sÃ»r")
            report.append("   - Restez nÃ©anmoins vigilant")
        
        report.append("\n" + "=" * 80)
        report.append("Fin du rapport")
        report.append("=" * 80)
        
        report_text = "\n".join(report)
        
        # Affichage
        print("\n" + report_text)
        
        # Sauvegarde dans un fichier
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(report_text)
            print(f"\nğŸ’¾ Rapport sauvegardÃ© dans: {output_file}")
        
        # Sauvegarde JSON
        json_file = output_file.replace('.txt', '.json') if output_file else 'scan_results.json'
        with open(json_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)
        print(f"ğŸ’¾ DonnÃ©es JSON sauvegardÃ©es dans: {json_file}")
        
        return report_text


def main():
    """Fonction principale"""
    parser = argparse.ArgumentParser(
        description='Scanner de malware pour sites web',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:
  python malware_scanner.py https://example.com
  python malware_scanner.py https://example.com -o rapport.txt
  python malware_scanner.py https://suspicious-site.com --verbose
        """
    )
    
    parser.add_argument('url', help='URL du site Ã  analyser')
    parser.add_argument('-o', '--output', help='Fichier de sortie pour le rapport (optionnel)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Mode verbeux')
    
    args = parser.parse_args()
    
    # Validation de l'URL
    if not args.url.startswith(('http://', 'https://')):
        print("âŒ Erreur: L'URL doit commencer par http:// ou https://")
        return
    
    # CrÃ©ation du scanner
    scanner = MalwareScanner(args.url)
    
    # ExÃ©cution du scan
    try:
        results = scanner.scan()
        
        # GÃ©nÃ©ration du rapport
        output_file = args.output or f"malware_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        scanner.generate_report(output_file)
        
    except Exception as e:
        print(f"âŒ Erreur lors de l'analyse: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()


if __name__ == "__main__":
    main()
